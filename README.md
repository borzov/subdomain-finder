# Subdomain Finder

Инструмент для поиска поддоменов с использованием нескольких методов одновременно. Находит поддомены через SSL-сертификаты, OSINT источники и DNS brute forcing, затем проверяет их существование через DNS.

## Что делает

Скрипт собирает поддомены из разных источников:
- **crt.sh** — поддомены из SSL-сертификатов
- **Sublist3r** — OSINT поиск (если установлен)
- **DNS brute forcing** — перебор по словарю (опционально)

Затем проверяет каждый найденный поддомен через DNS и показывает только те, которые действительно существуют и резолвятся в IP-адреса.

## Установка

```bash
git clone https://github.com/borzov/subdomain-finder.git
cd subdomain-finder
pip install -r requirements.txt
```

Зависимости устанавливаются автоматически из `requirements.txt`.

## Использование

Базовый запуск:

```bash
python3 find_subdomains.py -d example.com
```

Этот вариант использует только crt.sh и Sublist3r (если установлен). Словарь не обязателен.

Если нужно добавить DNS brute forcing:

```bash
python3 find_subdomains.py -d example.com -w wordlist.txt
```

Скрипт сначала соберет поддомены из всех источников, объединит их в один список, затем проверит каждый через DNS.

## Параметры

**Обязательные:**
- `-d, --domain` — целевой домен

**Опциональные:**
- `-w, --wordlist` — путь к словарю для brute forcing (если не указан, используется только пассивный поиск)
- `-o, --output` — имя файла для результатов (по умолчанию `results.{format}` в `results/{domain}/`)
- `-f, --format` — формат вывода: `txt`, `json` или `csv` (по умолчанию `txt`)
- `-c, --concurrent` — количество одновременных DNS запросов (по умолчанию 150)
- `-t, --timeout` — таймаут DNS запросов в секундах (по умолчанию 2.0)
- `--dns` — кастомные DNS серверы через пробел, например: `--dns 8.8.8.8 1.1.1.1`
- `-v, --verbose` — подробный вывод ошибок
- `--no-banner` — убрать баннер при запуске
- `--keenetic` — сгенерировать файл маршрутов для роутеров Keenetic

## Примеры

Поиск без словаря (только пассивные методы):

```bash
python3 find_subdomains.py -d raycast.com
```

С словарем для полного покрытия:

```bash
python3 find_subdomains.py -d raycast.com -w wordlist.txt
```

Экспорт в JSON:

```bash
python3 find_subdomains.py -d raycast.com -f json
```

Результат сохранится в `results/raycast.com/results.json`.

С генерацией файла маршрутов для Keenetic:

```bash
python3 find_subdomains.py -d raycast.com --keenetic
```

Это создаст файл `results/raycast.com/raycast.com.dat` с командами `route add` для всех найденных IP-сетей.

## Формат результатов

По умолчанию результаты сохраняются в текстовом формате:

```
api.raycast.com
  -> 143.204.176.50
  -> 143.204.176.126

dev.raycast.com
  -> 3.174.141.90
  -> 3.174.141.16
```

Поддомен считается найденным только если он резолвится в IP-адреса через DNS. Если поддомен был в сертификате, но не резолвится, он не попадет в результаты.

## Генерация маршрутов для Keenetic

При использовании флага `--keenetic` скрипт создает файл `results/{domain}/{domain}.dat` с маршрутами для роутеров Keenetic. Все IP-адреса найденных поддоменов конвертируются в сети /24:

```
route add 13.224.132.0 mask 255.255.255.0 0.0.0.0
route add 18.154.84.0 mask 255.255.255.0 0.0.0.0
```

Файл можно импортировать в роутер Keenetic через веб-интерфейс.

## Где взять словарь

Для DNS brute forcing нужен файл со списком возможных поддоменов (по одному на строку). Можно использовать:

- [SecLists](https://github.com/danielmiessler/SecLists) — большой сборник словарей
- [all.txt от jhaddix](https://gist.github.com/jhaddix/86a06c5dc309d08580a018c66354a056) — популярный словарь
- Создать свой список поддоменов

Словарь не обязателен — скрипт хорошо работает и без него, используя только crt.sh и Sublist3r.

## Как это работает

1. Сбор поддоменов:
   - Запрос к crt.sh API для получения поддоменов из SSL-сертификатов
   - Запуск Sublist3r (если установлен) для OSINT поиска
   - Загрузка словаря (если указан) для brute forcing

2. Дедупликация:
   - Все найденные поддомены объединяются в один список
   - Удаляются дубликаты

3. Проверка существования:
   - Каждый поддомен проверяется через DNS A-запрос
   - Если поддомен не резолвится, он пропускается
   - Проверяется наличие wildcard DNS и фильтруются ложные срабатывания

4. Сохранение результатов:
   - Результаты сохраняются в папке `results/{domain}/` в указанном формате
   - Опционально генерируется файл маршрутов для Keenetic (`results/{domain}/{domain}.dat`)

Все методы работают параллельно для максимальной скорости.

## Производительность

Скорость зависит от количества найденных поддоменов и DNS-серверов. Обычно это 200-500 запросов в секунду. Для больших доменов (сотни поддоменов) полное сканирование занимает несколько минут.

## Требования

- Python 3.7+
- dnspython >= 2.7.0
- requests >= 2.31.0
- urllib3 >= 2.0.0

Все зависимости указаны в `requirements.txt` и устанавливаются автоматически при установке.

**Опционально:**
- Sublist3r — для OSINT поиска (устанавливается отдельно, не обязателен)

## История версий

### Версия 2.0 (текущая)

**Основные улучшения:**
- Полностью асинхронная реализация на asyncio для высокой производительности
- Автоматическое создание структуры папок `results/{domain}/` для каждого домена
- Валидация входных данных (домен, параметры)
- Защита от path traversal атак при сохранении файлов
- Генерация файлов маршрутов для роутеров Keenetic (опционально)
- Улучшенная обработка ошибок (JSON от crt.sh, DNS таймауты)
- Поддержка множественных форматов вывода (TXT, JSON, CSV)
- Автоматическое обнаружение wildcard DNS с фильтрацией ложных срабатываний
- Детальная типизация кода (PEP 484)
- Соответствие стандартам PEP 8 и PEP 257

**Методы поиска:**
- Поиск через SSL-сертификаты (crt.sh API)
- OSINT поиск через Sublist3r (если установлен)
- DNS brute forcing по словарю (опционально)
- Проверка существования всех найденных поддоменов через DNS

**Производительность:**
- 200-500+ запросов в секунду
- Асинхронная обработка запросов
- Параллельное выполнение методов поиска

### Версия 1.0 (начальная)

**Функционал:**
- Поиск поддоменов через три метода: Sublist3r, crt.sh API, DNS brute forcing
- Синхронная реализация с ThreadPoolExecutor
- Сохранение результатов в один файл `subdomains.txt` в корне проекта
- Базовая обработка ошибок
- Простой текстовый формат вывода

**Ограничения:**
- Меньшая производительность из-за синхронного подхода
- Все результаты в одном файле без организации по доменам
- Отсутствие валидации входных данных
- Нет защиты от path traversal
- Нет генерации маршрутов для роутеров

## Лицензия

Этот проект находится в свободном доступе. Используйте по своему усмотрению.
